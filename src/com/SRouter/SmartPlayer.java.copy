/**
 * Created by Ning Jiang on 9/2/14.
 */


package com.SRouter;

import com.xuggle.xuggler.*;
import com.xuggle.xuggler.demos.VideoImage;

import java.awt.image.BufferedImage;
import java.io.DataOutputStream;
import java.io.FileInputStream;
import java.net.Socket;


public class SmartPlayer {
    private String neighboringRouterIP = "127.0.0.1";
    private int SMART_Client_Router_Port = 8999;
    private int SMART_Server_Port = 7999;
    private String videoServerIP = "127.0.0.1";
    private String videoFileName = "2012.flv";
    private String videoFilePath = "C:\\Users\\Ning Jiang\\Videos\\2012.flv";

    public SmartPlayer(String[] args) {
        if (args.length > 0) {
            String configFilePath = args[0];
            try {
                FileInputStream configFileStream = new FileInputStream(configFilePath);
            }
            catch (Exception e) {
                System.out.println("Failed to open configuration file " + e.getMessage());
            }
        }
    }

    private static VideoImage mScreen = null;

    private static void updateJavaWindow(BufferedImage javaImage)
    {
        mScreen.setImage(javaImage);
    }

    /**
     * Opens a Swing window on screen.
     */
    private static void openJavaWindow()
    {
        mScreen = new VideoImage();
    }

    /**
     * Forces the swing thread to terminate; I'm sure there is a right
     * way to do this in swing, but this works too.
     */
    private static void closeJavaWindow()
    {
        System.exit(0);
    }


    private void handlePackets(Socket clientSocket) {
        if (!IVideoResampler.isSupported(
                IVideoResampler.Feature.FEATURE_COLORSPACECONVERSION))
            throw new RuntimeException("you must install the GPL version" +
                    " of Xuggler (with IVideoResampler support) for " +
                    "this demo to work");

        IContainer container = IContainer.make();

        // we attempt to open up the container
        try {
            IContainerFormat rFormat = IContainerFormat.make();
            rFormat.setInputFormat("flv");
            int result = container.open(clientSocket.getInputStream(), rFormat);

            // check if the operation was successful
            if (result < 0)
                throw new RuntimeException("Failed to open media file");

            int numStreams = container.getNumStreams();

            // and iterate through the streams to find the first video stream
            int videoStreamId = -1;
            IStreamCoder videoCoder = null;
            for(int i = 0; i < numStreams; i++)
            {
                // Find the stream object
                IStream stream = container.getStream(i);
                // Get the pre-configured decoder that can decode this stream;
                IStreamCoder coder = stream.getStreamCoder();

                if (coder.getCodecType() == ICodec.Type.CODEC_TYPE_VIDEO)
                {
                    videoStreamId = i;
                    videoCoder = coder;
                    break;
                }
            }
            if (videoStreamId == -1)
                throw new RuntimeException("could not find video stream in container: ");

            /*
     * Now we have found the video stream in this file.  Let's open up our decoder so it can
     * do work.
     */
            if (videoCoder.open() < 0)
                throw new RuntimeException("could not open video decoder for container: "
                        );

            IVideoResampler resampler = null;
            if (videoCoder.getPixelType() != IPixelFormat.Type.BGR24)
            {
                // if this stream is not in BGR24, we're going to need to
                // convert it.  The VideoResampler does that for us.
                resampler = IVideoResampler.make(videoCoder.getWidth(),
                        videoCoder.getHeight(), IPixelFormat.Type.BGR24,
                        videoCoder.getWidth(), videoCoder.getHeight(), videoCoder.getPixelType());
                if (resampler == null)
                    throw new RuntimeException("could not create color space " +
                            "resampler for: ");
            }

            /*
     * And once we have that, we draw a window on screen
     */
            openJavaWindow();

    /*
     * Now, we start walking through the container looking at each packet.
     */
            IPacket packet = IPacket.make();
            long firstTimestampInStream = Global.NO_PTS;
            long systemClockStartTime = 0;
            while(container.readNextPacket(packet) >= 0)
            {
      /*
       * Now we have a packet, let's see if it belongs to our video stream
       */
                if (packet.getStreamIndex() == videoStreamId)
                {
        /*
         * We allocate a new picture to get the data out of Xuggler
         */
                    IVideoPicture picture = IVideoPicture.make(videoCoder.getPixelType(),
                            videoCoder.getWidth(), videoCoder.getHeight());

                    int offset = 0;
                    while(offset < packet.getSize())
                    {
          /*
           * Now, we decode the video, checking for any errors.
           *
           */
                        int bytesDecoded = videoCoder.decodeVideo(picture, packet, offset);
                        if (bytesDecoded < 0)
                            throw new RuntimeException("got error decoding video in: "
                                    );
                        offset += bytesDecoded;

          /*
           * Some decoders will consume data in a packet, but will not be able to construct
           * a full video picture yet.  Therefore you should always check if you
           * got a complete picture from the decoder
           */
                        if (picture.isComplete())
                        {
                            IVideoPicture newPic = picture;
            /*
             * If the resampler is not null, that means we didn't get the
             * video in BGR24 format and
             * need to convert it into BGR24 format.
             */
                            if (resampler != null)
                            {
                                // we must resample
                                newPic = IVideoPicture.make(resampler.getOutputPixelFormat(),
                                        picture.getWidth(), picture.getHeight());
                                if (resampler.resample(newPic, picture) < 0)
                                    throw new RuntimeException("could not resample video from: "
                                            );
                            }
                            if (newPic.getPixelType() != IPixelFormat.Type.BGR24)
                                throw new RuntimeException("could not decode video" +
                                        " as BGR 24 bit data in: ");

                            /**
                             * We could just display the images as quickly as we decode them,
                             * but it turns out we can decode a lot faster than you think.
                             *
                             * So instead, the following code does a poor-man's version of
                             * trying to match up the frame-rate requested for each
                             * IVideoPicture with the system clock time on your computer.
                             *
                             * Remember that all Xuggler IAudioSamples and IVideoPicture objects
                             * always give timestamps in Microseconds, relative to the first
                             * decoded item. If instead you used the packet timestamps, they can
                             * be in different units depending on your IContainer, and IStream
                             * and things can get hairy quickly.
                             */
                            if (firstTimestampInStream == Global.NO_PTS)
                            {
                                // This is our first time through
                                firstTimestampInStream = picture.getTimeStamp();
                                // get the starting clock time so we can hold up frames
                                // until the right time.
                                systemClockStartTime = System.currentTimeMillis();
                            } else {
                                long systemClockCurrentTime = System.currentTimeMillis();
                                long millisecondsClockTimeSinceStartofVideo =
                                        systemClockCurrentTime - systemClockStartTime;
                                // compute how long for this frame since the first frame in the
                                // stream.
                                // remember that IVideoPicture and IAudioSamples timestamps are
                                // always in MICROSECONDS,
                                // so we divide by 1000 to get milliseconds.
                                long millisecondsStreamTimeSinceStartOfVideo =
                                        (picture.getTimeStamp() - firstTimestampInStream)/1000;
                                final long millisecondsTolerance = 50; // and we give ourselfs 50 ms of tolerance
                                final long millisecondsToSleep =
                                        (millisecondsStreamTimeSinceStartOfVideo -
                                                (millisecondsClockTimeSinceStartofVideo +
                                                        millisecondsTolerance));
                                if (millisecondsToSleep > 0)
                                {
                                    try
                                    {
                                        Thread.sleep(millisecondsToSleep);
                                    }
                                    catch (InterruptedException e)
                                    {
                                        // we might get this when the user closes the dialog box, so
                                        // just return from the method.
                                        return;
                                    }
                                }
                            }

                            // And finally, convert the BGR24 to an Java buffered image
                            BufferedImage javaImage = Utils.videoPictureToImage(newPic);

                            // and display it on the Java Swing window
                            updateJavaWindow(javaImage);
                        }
                    }
                }
                else
                {
        /*
         * This packet isn't part of our video stream, so we just
         * silently drop it.
         */
                    do {} while(false);
                }

            /*
     * Technically since we're exiting anyway, these will be cleaned up by
     * the garbage collector... but because we're nice people and want
     * to be invited places for Christmas, we're going to show how to clean up.
     */
                if (videoCoder != null)
                {
                    videoCoder.close();
                    videoCoder = null;
                }
                if (container !=null)
                {
                    container.close();
                    container = null;
                }
                closeJavaWindow();
            }
            /*IMediaDebugListener debugListener = ToolFactory.makeDebugListener();
            IMediaReader reader = ToolFactory.makeReader(container);
            IMediaViewer mediaViewer = ToolFactory.makeViewer(IMediaViewer.Mode.VIDEO_ONLY, true);
            reader.addListener(mediaViewer);
            reader.addListener(debugListener); */

            // read out the contents of the media file, and sit back and watch
            //while (reader.readPacket() == null)
            //    do {} while(false);
        }
        catch (Exception e) {
            System.out.println("Failed to handle packet " + e.getMessage());
            e.printStackTrace();
        }
    }

    public void requestVideo(String fileName) {
        // Establish a channel with the immediate edge SMART router
        try {
            Socket clientSocket = new Socket(videoServerIP, SMART_Server_Port);
            String command = "Request " + fileName + "\n";
            byte[] sendData = command.getBytes();
            DataOutputStream os = new DataOutputStream(clientSocket.getOutputStream());
            os.writeBytes(command);
            os.flush();

            handlePackets(clientSocket);
        }
        catch (Exception e) {
            System.out.println("Error handling playback " + e.getMessage());
            e.printStackTrace();
        }
    }

    public void playVideo() {
        // first we create a Xuggler container object
        IContainer container = IContainer.make();

        // we attempt to open up the container
        int result = container.open(videoFilePath, IContainer.Type.READ, null);

        // check if the operation was successful
        if (result<0)
            throw new RuntimeException("Failed to open media file");

        // query how many streams the call to open found
        int numStreams = container.getNumStreams();

        // query for the total duration
        long duration = container.getDuration();

        // query for the file size
        long fileSize = container.getFileSize();

        // query for the bit rate
        long bitRate = container.getBitRate();

        System.out.println("Number of streams: " + numStreams);
        System.out.println("Duration (ms): " + duration);
        System.out.println("File Size (bytes): " + fileSize);
        System.out.println("Bit Rate: " + bitRate);

        // iterate through the streams to print their meta data
        for (int i = 0; i< numStreams; i++) {

            // find the stream object
            IStream stream = container.getStream(i);

            // get the pre-configured decoder that can decode this stream;
            IStreamCoder coder = stream.getStreamCoder();

            System.out.println("*** Start of Stream Info ***");

            System.out.printf("stream %d: ", i);
            System.out.printf("type: %s; ", coder.getCodecType());
            System.out.printf("codec: %s; ", coder.getCodecID());
            System.out.printf("duration: %s; ", stream.getDuration());
            System.out.printf("start time: %s; ", container.getStartTime());
            System.out.printf("timebase: %d/%d; ",
                    stream.getTimeBase().getNumerator(),
                    stream.getTimeBase().getDenominator());
            System.out.printf("coder tb: %d/%d; ",
                    coder.getTimeBase().getNumerator(),
                    coder.getTimeBase().getDenominator());
            System.out.println();

            if (coder.getCodecType() == ICodec.Type.CODEC_TYPE_AUDIO) {
                System.out.printf("sample rate: %d; ", coder.getSampleRate());
                System.out.printf("channels: %d; ", coder.getChannels());
                System.out.printf("format: %s", coder.getSampleFormat());
            }
            else if (coder.getCodecType() == ICodec.Type.CODEC_TYPE_VIDEO) {
                System.out.printf("width: %d; ", coder.getWidth());
                System.out.printf("height: %d; ", coder.getHeight());
                System.out.printf("format: %s; ", coder.getPixelType());
                System.out.printf("frame-rate: %5.2f; ", coder.getFrameRate().getDouble());
            }

            System.out.println();
            System.out.println("*** End of Stream Info ***");

        }

    }


    public static void main(String[] args) {
        SmartPlayer smartPlayer = new SmartPlayer(args);
        smartPlayer.requestVideo("2012.flv");
    }
}
